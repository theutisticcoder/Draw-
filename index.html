<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="manifest" href="manifest.json" />
    <title>ArtFusion - Free Oil Painting Online!</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fascinate+Inline&display=swap" rel="stylesheet">
    <link rel="icon" href="icon.png">
    <!-- <script src="service-worker.js"></script> -->
    <script src="https://cdn.jsdelivr.net/npm/localforage@1.10.0/dist/localforage.min.js"></script>
    <style>
        html,
        body {
            overscroll-behavior-x: none;
        }

        button {
            color: white;
            background-color: blue;
        }

        #name {
            font-family: "Fascinate Inline", system-ui;
            font-weight: 400;
        }

        html {
            overflow: hidden;
        }

        body {
            overflow: hidden;
            margin: 0;
            padding: 0;
            height: 100%;
            background-color: black;
            font-family: sans-serif;
        }

        h1 {
            background: #7F7FD5;
            background: linear-gradient(to right, blue, green, orange);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #drawing-board {
            cursor: crosshair;
            position: absolute;
            border: 1px solid black;
            background-color: white;
        }

        .container {
            height: 100%;
            display: flex;
            position: relative;
        }

        #toolbar {
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            padding: 5px;
            width: 10vw;
            background-color: lightblue;
            transition: transform 0.3s ease;
            min-width: 120px;
        }

        #toolbar.hidden {
            transform: translateX(-100%);
        }

        #toolbar label {
            font-size: 12px;
        }

        #toolbar #lineWidth {
            height: 30%;
            left: -50%;
            position: relative;
        }

        button {
            overflow: hidden;
            cursor: pointer;
        }

        #clear {
            background-color: #1565c0;
            border: none;
            border-radius: 4px;
            color: white;
            padding: 2px;
        }

        #erase {
            background-color: black;
            border: none;
            border-radius: 4px;
            color: white;
            padding: 2px;
        }

        h1 {
            color: black;
            font-size: 100pt;
        }

        #name {
            font-size: 30pt;
        }

        #map {
            rotate: 1 0 0 20deg;
            position: relative;
            left: 200px;
            top: -800px;
        }

        img {
            overflow: hidden;
        }

        #new {
            font-size: 100pt;
            background: cyan;
            width: 20vh;
            color: black;
            height: 20vh;
            position: absolute;
            left: 0px;
            border-radius: 50%;
            z-index: 100;
        }

        #gallery {
            height: 100vh;
            width: 100vw;
            overflow-y: scroll;
            background: darkblue;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 50;
            display: flex;
            flex-wrap: wrap;
            align-content: flex-start;
        }

        #toolbar * {
            margin-bottom: 6px;
            position: relative;
            z-index: 3;
            height: 45px;
            font-size: 15pt;
        }

        label {
            font-size: 30pt;
        }

        #bi {
            background: black;
        }

        button {
            font-size: 45pt;
            width: fit-content;
            height: fit-content;
        }
        
        /* Toggle button for toolbar */
        #toggle-toolbar {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0,0,0,0.5);
            color: white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: 2px solid white;
        }
    </style>
</head>

<body>
    <div id="gallery" style="display: none;">
        <button id="new">+<br><br></button>
        <button hidden onclick="location.href = 'ar.html'">See Gallery</button>
    </div>
    <div id="toggle-toolbar">‚ò∞</div>
    <section class="container">
        <div id="toolbar" class="hidden">
            <video hidden></video>
            <img onclick="location.reload()" id="name" height="50px" width="50px" src="icon.png">
            <label style="font-size: 30pt;" for="stroke">üé®</label>
            <input id="stroke" name='stroke' type="color" value="#000000">
            <label style="font-size: 30pt;" for="lineWidth">‚ÜîÔ∏è</label>
            <input id="lineWidth" name='lineWidth' style="writing-mode: vertical-lr;direction: rtl;" type="range"
                min="1" max="40" value="5">
            <button style="font-size: 30pt;" id="clear">üóëÔ∏è</button>
            <button style="font-size: 30pt;" id="undo" hidden>‚Ü©Ô∏è</button>
            <button style="font-size: 30pt;" id="dry">ñ£ò</button>
            <button style="font-size: 30pt;" id="save">üíæ</button>
        </div>
        <div id="map"></div>
        <div class="drawing-board">
            <canvas id="drawing-board"></canvas>

            <iframe src="palette.html?v=1" style="width: 50vw; height: 40vh;position: relative; left: 50vw;"
                frameborder="2"></iframe>
            <br>
            <button id="select"
                style="width: 40vw;position: relative; left: 50vw; font-size: 15pt;">Select<br>Color</button>

        </div>
    </section>
    <script>

        // --- Core Logic Setup ---
        const canvas = document.getElementById('drawing-board');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const toolbar = document.getElementById('toolbar');
        
        // Set Canvas Size (Responsive)
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            // Re-apply background texture on resize if needed, 
            // but for now we keep drawing data. 
            // Note: Resizing clears the canvas in standard HTML5.
        }
        
        // Initial Sizing
        canvas.height = window.innerHeight * 0.8;
        canvas.width = window.innerWidth * 0.5;
        canvas.style.height = canvas.height + "px";
        canvas.style.width = canvas.width + "px";

        // State Variables
        let isPainting = false;
        let lineWidth = 5;
        let currentColor = "#000000";
        let lastX = 0;
        let lastY = 0;
        
        // Undo/Redo & Storage
        let undoStack = [];
        const MAX_UNDO = 10;
        
        // Assets
        const brushImage = new Image();
        brushImage.src = 'brush.png';
        
        const textureImage = new Image();
        textureImage.src = "canvas.jpeg";

        // --- Helper Functions ---

        // Linear Interpolation for Colors (The Fix for Mixing)
        function lerpColor(color1, color2, t) {
            // Parse hex #RRGGBB
            const r1 = parseInt(color1.slice(1, 3), 16);
            const g1 = parseInt(color1.slice(3, 5), 16);
            const b1 = parseInt(color1.slice(5, 7), 16);

            const r2 = parseInt(color2.slice(1, 3), 16);
            const g2 = parseInt(color2.slice(3, 5), 16);
            const b2 = parseInt(color2.slice(5, 7), 16);

            const r = Math.round(r1 + t * (r2 - r1));
            const g = Math.round(g1 + t * (g2 - g1));
            const b = Math.round(b1 + t * (b2 - b1));

            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        // Sample the color currently on the canvas at (x, y)
        function getPixelColor(x, y) {
            const p = ctx.getImageData(x, y, 1, 1).data;
            // If transparent or white (background), return white for mixing
            if (p[3] === 0 || (p[0]===255 && p[1]===255 && p[2]===255)) return "#ffffff";
            return `#${p[0].toString(16).padStart(2,'0')}${p[1].toString(16).padStart(2,'0')}${p[2].toString(16).padStart(2,'0')}`;
        }

        // Save current state for Undo
        function saveState() {
            if (undoStack.length >= MAX_UNDO) undoStack.shift();
            undoStack.push(canvas.toDataURL());
        }

        // Restore state
        function restoreState() {
            if (undoStack.length > 0) {
                const img = new Image();
                img.src = undoStack.pop();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
            }
        }

        // --- Drawing Logic ---

        function interpolateAndDraw(x0, y0, x1, y1) {
            const distance = Math.hypot(x1 - x0, y1 - y0);
            const steps = Math.max(1, Math.ceil(distance / 2)); // Density of stamps

            for (let i = 0; i <= steps; i++) {
                const t = i / steps;
                const x = x0 + (x1 - x0) * t;
                const y = y0 + (y1 - y0) * t;
                
                // 1. Get the color already on the canvas at this spot
                const canvasColor = getPixelColor(x, y);
                
                // 2. Blend it with the selected color (50% mix for "wet" look)
                const mixedColor = lerpColor(currentColor, canvasColor, 0.5);
                
                // 3. Draw the stamp with the mixed color
                drawBrushStamp(x, y, mixedColor);
            }
        }

        function drawBrushStamp(x, y, color) {
            const size = lineWidth * 6;
            
            ctx.save();
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 0.6; // Simulates wet paint transparency

            // Create a pattern from the brush image, tinted with the mixed color
            // We use a temporary canvas to generate the pattern every time (optimization possible here)
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = brushImage.width || 64;
            tempCanvas.height = brushImage.height || 64;
            const tCtx = tempCanvas.getContext('2d');
            
            // Draw mask
            if(brushImage.complete) {
                tCtx.drawImage(brushImage, 0, 0, tempCanvas.width, tempCanvas.height);
            } else {
                // Fallback: circle
                tCtx.beginPath();
                tCtx.arc(32, 32, 30, 0, Math.PI*2);
                tCtx.fill();
            }

            // Tint it
            const imageData = tCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            const data = imageData.data;
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);

            for (let i = 0; i < data.length; i += 4) {
                if (data[i+3] > 0) {
                    data[i] = r;
                    data[i+1] = g;
                    data[i+2] = b;
                }
            }
            tCtx.putImageData(imageData, 0, 0);

            // Draw to main canvas
            const pattern = ctx.createPattern(tempCanvas, 'repeat');
            ctx.fillStyle = pattern;
            
            // Slight jitter for organic feel
            const jitter = (Math.random() - 0.5) * 2;
            ctx.translate(x + jitter, y + jitter);
            ctx.rotate(Math.random() * 0.2 - 0.1); // Random rotation
            ctx.fillRect(-size/2, -size/2, size, size);
            
            ctx.restore();
        }

        // --- Event Listeners ---

        function startPaint(e) {
            // Don't start if clicking toolbar or iframe
            if (e.target.closest('#toolbar') || e.target.closest('iframe')) return;
            
            isPainting = true;
            const { x, y } = getCoords(e);
            lastX = x;
            lastY = y;
            
            // Save state before starting a new stroke
            saveState();
            
            // Initial dot
            drawBrushStamp(x, y, currentColor);
        }

        function endPaint() {
            if (isPainting) {
                isPainting = false;
            }
        }

        function paint(e) {
            if (!isPainting) return;
            e.preventDefault();
            
            const { x, y } = getCoords(e);
            
            // Interpolate between last point and current to prevent gaps
            interpolateAndDraw(lastX, lastY, x, y);
            
            lastX = x;
            lastY = y;
        }

        function getCoords(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches && e.touches.length > 0) {
                return {
                    x: e.touches[0].clientX - rect.left,
                    y: e.touches[0].clientY - rect.top
                };
            }
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        // Mouse
        canvas.addEventListener('mousedown', startPaint);
        window.addEventListener('mouseup', endPaint); // Window to catch drags outside
        canvas.addEventListener('mousemove', paint);

        // Touch
        canvas.addEventListener('touchstart', startPaint, { passive: false });
        window.addEventListener('touchend', endPaint);
        canvas.addEventListener('touchmove', paint, { passive: false });

        // --- UI Controls ---

        // Toggle Toolbar
        document.getElementById('toggle-toolbar').addEventListener('click', () => {
            toolbar.classList.toggle('hidden');
        });

        // Color Picker
        document.getElementById('stroke').addEventListener('input', (e) => {
            currentColor = e.target.value;
        });

        // Line Width
        document.getElementById('lineWidth').addEventListener('input', (e) => {
            lineWidth = parseInt(e.target.value);
        });

        // Clear Canvas
        document.getElementById('clear').addEventListener('click', () => {
            saveState(); // Save before clearing
            ctx.fillStyle = "white";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Re-apply texture if needed, or leave white
            if (textureImage.complete) {
                const pattern = ctx.createPattern(textureImage, "repeat");
                ctx.fillStyle = pattern;
                ctx.globalAlpha = 0.3;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1.0;
            }
        });

        // Undo
        document.getElementById('undo').addEventListener('click', restoreState);
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                e.preventDefault();
                restoreState();
            }
        });

        // Save Image
        document.getElementById('save').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'artfusion-painting.png';
            link.href = canvas.toDataURL();
            link.click();
        });
        
        // Select Color from Palette (Iframe)
        document.getElementById("select").addEventListener('click', (e) => {
            try {
                const iframe = document.querySelector("iframe");
                if (iframe && iframe.contentWindow && iframe.contentWindow.data) {
                    const data = iframe.contentWindow.data.data; // Assuming palette.html exports data object
                    // Simple average
                    let r = 0, g = 0, b = 0;
                    for(let i=0; i<data.length; i+=4) {
                        r += data[i]; g += data[i+1]; b += data[i+2];
                    }
                    const count = data.length / 4;
                    const hex = `#${Math.round(r/count).toString(16).padStart(2,'0')}${Math.round(g/count).toString(16).padStart(2,'0')}${Math.round(b/count).toString(16).padStart(2,'0')}`;
                    currentColor = hex;
                    document.getElementById('stroke').value = hex;
                }
            } catch (err) {
                console.log("Could not select color from palette");
            }
        });

        // --- Initialization ---
        
        // Initialize Background
        function initBackground() {
            if (textureImage.complete) {
                const pattern = ctx.createPattern(textureImage, "repeat");
                ctx.fillStyle = pattern;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = "white";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        textureImage.onload = initBackground;
        textureImage.onerror = () => {
            // Fallback if texture missing
            ctx.fillStyle = "#f0f0f0";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        };

        // Start with a blank state in undo stack
        setTimeout(() => {
            saveState();
        }, 100);

    </script>
</body>

</html>
