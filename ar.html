<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>MuseumAR</title>
  <style>
    body, html { margin: 0; overflow: hidden; }
    #startButton {
      position: absolute;
      z-index: 2;
      top: 10px;
      left: 10px;
      padding: 10px 20px;
      font-size: 18px;
      background: #007aff;
      color: white;
      border: none;
      border-radius: 5px;
    }
  </style>
</head>
<body>

<button id="startButton">Start AR</button>

<script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.10.0/localforage.min.js"></script>
<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js';
  import { ZapparThree } from 'https://cdn.jsdelivr.net/npm/@zappar/zappar-threejs@6.0.0/build/zappar-threejs.module.js';

  const startButton = document.getElementById('startButton');

  let camera, scene, renderer;
  let arCamera, arSessionManager;
  let placedMesh = null;
  let lastHitPose = null;

  // Helper: Save placement to localforage
  function savePlacement(position, quaternion) {
    const placement = {
      position: { x: position.x, y: position.y, z: position.z },
      quaternion: { x: quaternion.x, y: quaternion.y, z: quaternion.z, w: quaternion.w }
    };
    localforage.setItem('placement', placement).catch(console.error);
  }

  // Helper: Load placement from localforage
  async function loadPlacement() {
    try {
      return await localforage.getItem('placement');
    } catch (e) {
      console.error('Error loading placement:', e);
      return null;
    }
  }

  // Load artwork data URL from localforage
  async function loadArtworkDataUrl() {
    try {
      const dataUrl = await localforage.getItem('works');
      if (!dataUrl) throw new Error('No artwork found in localforage under "works"');
      return dataUrl;
    } catch (e) {
      alert('Failed to load artwork image from localforage. Please save your artwork first.');
      throw e;
    }
  }

  startButton.onclick = async () => {
    startButton.style.display = 'none';

    // Setup renderer and scene
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);
    document.body.appendChild(renderer.domElement);

    scene = new THREE.Scene();

    arCamera = new ZapparThree.Camera();
    arSessionManager = new ZapparThree.SessionManager();
    arSessionManager.start();
    scene.add(arCamera);

    // Load artwork texture from localforage Data URL
    const dataUrl = await loadArtworkDataUrl();

    const textureLoader = new THREE.TextureLoader();
    textureLoader.load(dataUrl, async (artworkTexture) => {
      const planeGeometry = new THREE.PlaneGeometry(1, 1);
      const planeMaterial = new THREE.MeshBasicMaterial({ map: artworkTexture, side: THREE.DoubleSide });
      placedMesh = new THREE.Mesh(planeGeometry, planeMaterial);
      placedMesh.visible = false;
      scene.add(placedMesh);

      // Try to load saved placement & apply
      const savedPlacement = await loadPlacement();
      if (savedPlacement && placedMesh) {
        placedMesh.position.set(
          savedPlacement.position.x,
          savedPlacement.position.y,
          savedPlacement.position.z
        );
        placedMesh.quaternion.set(
          savedPlacement.quaternion.x,
          savedPlacement.quaternion.y,
          savedPlacement.quaternion.z,
          savedPlacement.quaternion.w
        );
        placedMesh.visible = true;
      }
    });

    // Start AR session
    const session = await navigator.xr.requestSession('immersive-ar', { requiredFeatures: ['hit-test'] });
    arSessionManager.xrSession = session;
    arCamera.updateFrame(session);

    const referenceSpace = await session.requestReferenceSpace('viewer');
    const hitTestSource = await session.requestHitTestSource({ space: referenceSpace });

    session.requestAnimationFrame(onXRFrame);

    // On tap, place or move artwork and save coordinates
    window.addEventListener('click', () => {
      if (!placedMesh) return;
      if (!placedMesh.visible && lastHitPose) {
        placedMesh.position.set(lastHitPose.x, lastHitPose.y, lastHitPose.z);
        placedMesh.quaternion.set(lastHitPose.qx, lastHitPose.qy, lastHitPose.qz, lastHitPose.qw);
        placedMesh.visible = true;
        savePlacement(placedMesh.position, placedMesh.quaternion);
      } else if (lastHitPose) {
        // Optional: allow moving the artwork after placement by tapping again
        placedMesh.position.set(lastHitPose.x, lastHitPose.y, lastHitPose.z);
        placedMesh.quaternion.set(lastHitPose.qx, lastHitPose.qy, lastHitPose.qz, lastHitPose.qw);
        savePlacement(placedMesh.position, placedMesh.quaternion);
      }
    });

    function onXRFrame(time, frame) {
      const session = frame.session;
      const pose = frame.getViewerPose(referenceSpace);

      if (pose) {
        const xrViewer = pose.views[0];
        arCamera.cameraMatrix.fromArray(xrViewer.transform.matrix);
        arCamera.cameraMatrix.decompose(arCamera.position, arCamera.quaternion, arCamera.scale);
        arCamera.updateMatrixWorld(true);

        const hitTestResults = frame.getHitTestResults(hitTestSource);
        if (hitTestResults.length > 0) {
          const hit = hitTestResults[0];
          const hitPose = hit.getPose(referenceSpace);
          if (hitPose) {
            lastHitPose = {
              x: hitPose.transform.position.x,
              y: hitPose.transform.position.y,
              z: hitPose.transform.position.z,
              qx: hitPose.transform.orientation.x,
              qy: hitPose.transform.orientation.y,
              qz: hitPose.transform.orientation.z,
              qw: hitPose.transform.orientation.w,
            };
            // You can add a reticle here if you want
          }
        }
      }

      renderer.render(scene, arCamera);
      session.requestAnimationFrame(onXRFrame);
    }
  };
</script>

</body>
</html>
