<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Ultimate Oil Painting Simulator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body { font-family: 'Segoe UI', Arial, sans-serif; background: #f8f5ef; color: #333; margin: 0; padding: 0; }
    header { background: #47392f; color: #fff; padding: 1.5rem 0; text-align: center; box-shadow: 0 2px 5px rgba(60,40,20,0.08); }
    header h1 { margin: 0; font-family: 'Georgia', serif; font-size: 2.7rem; letter-spacing: 2px; text-shadow: 0 2px 0 #2e1c0d; }
    #toolbar { display: flex; justify-content: center; gap: 1.2rem; padding: 1.2rem; background: #ede3d5; box-shadow: 0 2px 5px rgba(60,40,20,0.04); flex-wrap: wrap; }
    #toolbar > * { font-size: 1rem; padding: 0.45rem 1.2rem; border-radius: 6px; border: 1px solid #cfc2a8; background: #fff; }
    #toolbar label { font-weight: 600; margin-right: 0.3rem; }
    #toolGroup { display: flex; align-items: center; gap: 0.5rem; }
    main { display: flex; flex-direction: row-reverse; justify-content: center; align-items: flex-start; min-height: 80vh; padding: 2rem 0; gap: 2rem; }
    #canvas-wrapper { box-shadow: 0 4px 24px rgba(80,40,5,0.14); border: 2px solid #cfc2a8; background: #fffefa; border-radius: 10px; padding: 1rem; margin: 1rem; }
    #palette-wrapper { box-shadow: 0 2px 14px rgba(80,40,5,0.09); border: 2px solid #cfc2a8; background: #f6f1e7; border-radius: 10px; padding: 1rem; margin: 1rem; width: 230px; flex-shrink: 0; display: flex; flex-direction: column; align-items: center; }
    #palette-canvas { display: block; width: 200px; height: 200px; background: #eee4d0 url('https://www.transparenttextures.com/patterns/canvas-fabric.png'); border-radius: 50%; box-shadow: 0 1px 6px rgba(60,40,20,0.08); border: 1.5px solid #cfc2a8; margin-bottom: 1rem; touch-action: none; }
    #palette-instructions { font-size: 0.97rem; color: #7b6652; margin-bottom: 1.2rem; text-align: center; }
    .palette-color-btn { width: 1.5em; height: 1.5em; border-radius: 50%; border: 1px solid #cfc2a8; margin-right: 0.35em; cursor: pointer; display: inline-block; vertical-align: middle; }
    .palette-color-btn.selected { box-shadow: 0 0 0 3px #7d5a2a; }
    canvas { display: block; background: #eee4d0 url('https://www.transparenttextures.com/patterns/canvas-fabric.png'); border-radius: 8px; box-shadow: 0 1px 6px rgba(60,40,20,0.12); cursor: crosshair; margin: 0 auto; touch-action: none; }
    #footer { text-align: center; font-size: 1rem; color: #8b7764; margin: 2rem 0 0 0; }
    #lighting-label { border: none; background: none; color: #7b6652; font-weight: 600; cursor: pointer; margin-right: 0.2rem; }
  </style>
</head>
<body>
<header>
  <h1>Ultimate Oil Painting Simulator</h1>
  <div>Palette mixing, palette knife, and realistic oil pigment blending with per-pixel depth.</div>
</header>
<nav id="toolbar">
  <span><label for="color">Color</label><input type="color" id="color" value="#a65b2a"></span>
  <span><label for="brushSize">Brush Size</label><input type="range" id="brushSize" min="8" max="60" value="24"></span>
  <span><label for="oiliness">Oiliness</label><input type="range" id="oiliness" min="0.05" max="1.0" step="0.01" value="0.6"></span>
  <span id="toolGroup"><label for="toolBrush"><input type="radio" name="tool" id="toolBrush" value="brush" checked>Brush</label><label for="toolKnife"><input type="radio" name="tool" id="toolKnife" value="knife">Palette Knife</label></span>
  <span><label id="lighting-label" for="lighting">Lighting</label><input type="checkbox" id="lighting" checked></span>
  <button id="clearBtn">Clear</button>
  <button id="downloadBtn">Download</button>
</nav>
<main>
  <div id="palette-wrapper">
    <canvas id="palette-canvas" width="200" height="200"></canvas>
    <div id="palette-instructions">Click to add color blobs.<br>Drag to mix colors.<br>Right-click or double-click to pick for brush.<br>Use palette or color picker!</div>
    <div id="palette-colors"></div>
  </div>
  <div id="canvas-wrapper">
    <canvas id="paintingCanvas" width="900" height="600"></canvas>
  </div>
</main>
<div id="footer">&copy; 2025 Ultimate Oil Painting Simulator</div>
<script>
// --- Core RYB Mixing and helpers remain the same (omitted for brevity) ---
// ======== Essential globals at the top ========
let painting = false;
let lastPoint = null;
let brushColor = "#a65b2a";
let brushSize = 24;
let oiliness = 0.6;
let lighting = true;
let tool = 'brush';

// Accurate RYB to RGB using Smith's algorithm (see https://web.archive.org/web/20170130153422/http://www.deathbysoftware.com/colors/index.html)
function lerp(t, a, b) { return a + (b - a) * t; }
function rybToRgb([r, y, b]) {
  r /= 255; y /= 255; b /= 255;
  // RYB cube corners mapped to RGB
  let white = [1, 1, 1];
  let red = [1, 0, 0];
  let yellow = [1, 1, 0];
  let blue = [0.163, 0.373, 0.6];
  let violet = [0.5, 0, 0.5];
  let green = [0, 0.66, 0.2];
  let orange = [1, 0.5, 0];
  let black = [0.2, 0.094, 0.0];

  // Interpolate along each axis
  let c0 = [lerp(r, white[0], red[0]), lerp(r, white[1], red[1]), lerp(r, white[2], red[2])];
  let c1 = [lerp(r, yellow[0], orange[0]), lerp(r, yellow[1], orange[1]), lerp(r, yellow[2], orange[2])];
  let c2 = [lerp(r, blue[0], violet[0]), lerp(r, blue[1], violet[1]), lerp(r, blue[2], violet[2])];
  let c3 = [lerp(r, green[0], black[0]), lerp(r, green[1], black[1]), lerp(r, green[2], black[2])];

  let c4 = [lerp(y, c0[0], c1[0]), lerp(y, c0[1], c1[1]), lerp(y, c0[2], c1[2])];
  let c5 = [lerp(y, c2[0], c3[0]), lerp(y, c2[1], c3[1]), lerp(y, c2[2], c3[2])];

  let c = [lerp(b, c4[0], c5[0]), lerp(b, c4[1], c5[1]), lerp(b, c4[2], c5[2])];

  return [Math.round(c[0]*255), Math.round(c[1]*255), Math.round(c[2]*255)];
}

// Approximate inverse (not perfect, but good for painting/mixing)
function rgbToRyb([rr, gg, bb]) {
  rr /= 255; gg /= 255; bb /= 255;
  // Extract whiteness from color
  let w = Math.min(rr, gg, bb);
  rr -= w; gg -= w; bb -= w;
  let mg = Math.max(rr, gg, bb);

  // Get Yellow out of Red+Green
  let y = Math.min(rr, gg);
  rr -= y; gg -= y;

  // If Blue & Green mix, split blue with green
  let b = Math.max(bb - y, 0);
  let g = Math.max(gg - b, 0);

  // Compose RYB
  let ryb_r = rr + y;
  let ryb_y = y + g;
  let ryb_b = b;

  // Normalize to [0,255]
  let max = Math.max(ryb_r, ryb_y, ryb_b);
  if (max > 0) {
    let n = mg / max;
    ryb_r *= n; ryb_y *= n; ryb_b *= n;
  }
  ryb_r += w;
  ryb_y += w;
  ryb_b += w;
  return [Math.round(ryb_r*255), Math.round(ryb_y*255), Math.round(ryb_b*255)];
}
function rybMix(c1, c2, ratio) {
  let ryb1 = rgbToRyb(c1), ryb2 = rgbToRyb(c2);
  let ryb = [
    ryb1[0] * (1 - ratio) + ryb2[0] * ratio,
    ryb1[1] * (1 - ratio) + ryb2[1] * ratio,
    ryb1[2] * (1 - ratio) + ryb2[2] * ratio
  ];
  return rybToRgb(ryb);
}
function hexToRgb(hex) {
  let c = hex.replace('#','');
  if (c.length === 3) c = c[0]+c[0]+c[1]+c[1]+c[2]+c[2];
  let num = parseInt(c, 16);
  return [
    (num >> 16) & 255,
    (num >> 8) & 255,
    num & 255
  ];
}
function rgbToHex([r, g, b]) {
  return '#' + [r, g, b].map(v => v.toString(16).padStart(2, '0')).join('');
}
function distance(a, b) {
  return Math.sqrt((a.x-b.x)**2+(a.y-b.y)**2);
}
// Palette implementation (unchanged)
const paletteCanvas = document.getElementById('palette-canvas');
const paletteCtx = paletteCanvas.getContext('2d');
let palette = [
  {x: 60, y: 140, r: 18, color: [180,60,40]},
  {x: 110, y: 120, r: 16, color: [255,210,30]},
  {x: 160, y: 160, r: 16, color: [32,110,200]},
  {x: 80, y: 60, r: 14, color: [60,150,60]},
  {x: 135, y: 60, r: 16, color: [245,248,243]}
];
function renderPalette() {
  paletteCtx.clearRect(0,0,200,200);
  for (let i=0; i<palette.length; ++i) {
    let blob = palette[i];
    paletteCtx.save();
    paletteCtx.beginPath();
    paletteCtx.ellipse(blob.x, blob.y, blob.r*1.15, blob.r*0.8, 0, 0, 2*Math.PI);
    paletteCtx.closePath();
    paletteCtx.fillStyle = `rgb(${blob.color[0]},${blob.color[1]},${blob.color[2]})`;
    paletteCtx.shadowColor = "#88684a";
    paletteCtx.shadowBlur = 2;
    paletteCtx.fill();
    paletteCtx.globalAlpha = 0.18;
    paletteCtx.beginPath();
    paletteCtx.arc(blob.x-blob.r/4, blob.y-blob.r/4, blob.r/2.7, 0, 2*Math.PI);
    paletteCtx.fillStyle = "#fff";
    paletteCtx.fill();
    paletteCtx.globalAlpha = 1;
    paletteCtx.restore();
  }
}
let draggingBlob = null, dragOffset = {x:0,y:0}, mixing = false, mixColor = null;
paletteCanvas.addEventListener('mousedown', e=>{
  let rect = paletteCanvas.getBoundingClientRect();
  let x = (e.clientX-rect.left), y = (e.clientY-rect.top);
  for (let i=palette.length-1; i>=0; --i) {
    let blob = palette[i];
    if (distance({x,y}, blob) < blob.r) {
      draggingBlob = blob;
      dragOffset = {x: blob.x-x, y: blob.y-y};
      mixing = e.ctrlKey || e.shiftKey || e.altKey || e.button===2;
      if (mixing) mixColor = blob.color;
      palette.splice(i,1);
      palette.push(blob);
      break;
    }
  }
});
paletteCanvas.addEventListener('mousemove', e=>{
  if (draggingBlob) {
    let rect = paletteCanvas.getBoundingClientRect();
    let x = (e.clientX-rect.left), y = (e.clientY-rect.top);
    if (mixing) {
      for (let blob of palette) {
        if (blob!==draggingBlob && distance({x, y}, blob)<(blob.r+draggingBlob.r)*0.95) {
          blob.color = rybMix(blob.color, mixColor, 0.38);
        }
      }
    } else {
      draggingBlob.x = Math.max(draggingBlob.r, Math.min(200-draggingBlob.r, x+dragOffset.x));
      draggingBlob.y = Math.max(draggingBlob.r, Math.min(200-draggingBlob.r, y+dragOffset.y));
    }
    renderPalette();
  }
});
paletteCanvas.addEventListener('mouseup', e=>{
  draggingBlob = null;
  mixing = false;
  mixColor = null;
});
paletteCanvas.addEventListener('mouseleave', e=>{
  draggingBlob = null;
  mixing = false;
  mixColor = null;
});
paletteCanvas.addEventListener('click', e=>{
  let rect = paletteCanvas.getBoundingClientRect();
  let x = (e.clientX-rect.left), y = (e.clientY-rect.top);
  let onBlob = palette.some(blob => distance({x,y},blob)<blob.r*0.95);
  if (!onBlob) {
    palette.push({x, y, r: 13+Math.random()*7, color: hexToRgb(document.getElementById('color').value)});
    renderPalette();
    updatePaletteUI();
  }
});
paletteCanvas.addEventListener('contextmenu', e=>{
  e.preventDefault();
  let rect = paletteCanvas.getBoundingClientRect();
  let x = (e.clientX-rect.left), y = (e.clientY-rect.top);
  for (let blob of palette)
    if (distance({x,y},blob)<blob.r) {
      selectPaletteColor(blob.color);
      break;
    }
});
paletteCanvas.addEventListener('dblclick', e=>{
  let rect = paletteCanvas.getBoundingClientRect();
  let x = (e.clientX-rect.left), y = (e.clientY-rect.top);
  for (let blob of palette)
    if (distance({x,y},blob)<blob.r) {
      selectPaletteColor(blob.color);
      break;
    }
});
function selectPaletteColor(color) {
  brushColor = rgbToHex(color);
  colorPicker.value = brushColor;
  setBrush();
  highlightPaletteColor();
}
function updatePaletteUI() {
  let d = document.getElementById('palette-colors');
  d.innerHTML = '';
  for (let i=0; i<palette.length; ++i) {
    let btn = document.createElement('span');
    btn.className = "palette-color-btn";
    btn.style.background = rgbToHex(palette[i].color);
    btn.onclick = ()=>selectPaletteColor(palette[i].color);
    d.appendChild(btn);
  }
  highlightPaletteColor();
}
function highlightPaletteColor() {
  let cs = document.getElementsByClassName('palette-color-btn');
  let bc = brushColor.toLowerCase();
  for (let i=0;i<cs.length;++i) {
    cs[i].classList.toggle('selected', rgbToHex(palette[i].color).toLowerCase() === bc);
  }
}
renderPalette();
updatePaletteUI();
/* ====== Canvas Painting Section ====== */
const canvas = document.getElementById('paintingCanvas');
const ctx = canvas.getContext('2d');
const colorPicker = document.getElementById('color');
const brushSizeInput = document.getElementById('brushSize');
const oilinessInput = document.getElementById('oiliness');
const lightingInput = document.getElementById('lighting');
const toolBrush = document.getElementById('toolBrush');
const toolKnife = document.getElementById('toolKnife');
const clearBtn = document.getElementById('clearBtn');
const downloadBtn = document.getElementById('downloadBtn');

toolBrush.addEventListener('change', ()=>{tool='brush';});
toolKnife.addEventListener('change', ()=>{tool='knife';});

function setBrush() {
  brushColor = colorPicker.value;
  brushSize = parseInt(brushSizeInput.value, 10);
  oiliness = parseFloat(oilinessInput.value);
  lighting = lightingInput.checked;
  highlightPaletteColor();
}
colorPicker.addEventListener('input', setBrush);
brushSizeInput.addEventListener('input', setBrush);
oilinessInput.addEventListener('input', setBrush);
lightingInput.addEventListener('change', setBrush);

function getPointer(e) {
  const rect = canvas.getBoundingClientRect();
  let x, y;
  if (e.touches) {
    x = e.touches[0].clientX - rect.left;
    y = e.touches[0].clientY - rect.top;
  } else {
    x = e.clientX - rect.left;
    y = e.clientY - rect.top;
  }
  return {x, y};
}
function impastoHighlight(x, y, r, color, angle = Math.PI/4) {
  ctx.save();
  ctx.globalAlpha = 0.12;
  const highlightColor = [Math.min(255, color[0]+90), Math.min(255, color[1]+90), Math.min(255, color[2]+90)];
  const grad = ctx.createRadialGradient(x + Math.cos(angle)*r*0.4, y + Math.sin(angle)*r*0.4, r*0.2, x, y, r*0.9);
  grad.addColorStop(0, `rgba(${highlightColor[0]},${highlightColor[1]},${highlightColor[2]},0.5)`);
  grad.addColorStop(1, `rgba(${color[0]},${color[1]},${color[2]},0)`);
  ctx.beginPath();
  ctx.arc(x, y, r, 0, 2*Math.PI);
  ctx.fillStyle = grad;
  ctx.fill();
  ctx.restore();
}
// Enhanced Dab with Direction + Streak Texture
function dabImpasto(x, y, r, color, oiliness, lighting, angle = null) {
  const left = Math.max(0, Math.floor(x - r));
  const top = Math.max(0, Math.floor(y - r));
  const right = Math.min(canvas.width, Math.ceil(x + r));
  const bottom = Math.min(canvas.height, Math.ceil(y + r));
  const width = right - left, height = bottom - top;
  const imgData = ctx.getImageData(left, top, width, height);
  for (let yy = 0; yy < height; yy++) {
    for (let xx = 0; xx < width; xx++) {
      const px = left + xx, py = top + yy;
      let relx = px - x, rely = py - y;
      let inside = false;
      if (angle !== null) {
        let cosA = Math.cos(angle), sinA = Math.sin(angle);
        let ex = (relx*cosA + rely*sinA) / (r*1.6);
        let ey = (-relx*sinA + rely*cosA) / (r*0.7);
        inside = ex*ex + ey*ey <= 1;
      } else {
        inside = relx*relx + rely*rely <= r*r;
      }
      if (!inside) continue;
      const idx = (yy * width + xx) * 4;
      const old = [imgData.data[idx], imgData.data[idx+1], imgData.data[idx+2]];
      let jitter = (Math.random()-0.5) * 0.08;
      let mixRatio = oiliness * (0.65 + jitter) + 0.25;
      mixRatio = Math.max(0, Math.min(1, mixRatio));
      const mixed = rybMix(old, color, mixRatio);
      // Add subtle streak texture
      if (angle !== null) {
        let stripe = Math.sin((relx*Math.cos(angle)+rely*Math.sin(angle)) / 4);
        mixed[0] = Math.min(255, mixed[0] + stripe*6);
        mixed[1] = Math.min(255, mixed[1] + stripe*6);
        mixed[2] = Math.min(255, mixed[2] + stripe*6);
      }
      imgData.data[idx] = mixed[0];
      imgData.data[idx+1] = mixed[1];
      imgData.data[idx+2] = mixed[2];
      imgData.data[idx+3] = Math.min(255, imgData.data[idx+3] + 180);
    }
  }
  ctx.putImageData(imgData, left, top);
  if (lighting) impastoHighlight(x, y, r, color, angle || Math.PI/4);
}

function knifeStroke(from, to, r, color, oiliness, lighting) {
  let dx = to.x - from.x, dy = to.y - from.y;
  let dist = Math.sqrt(dx*dx + dy*dy);
  let angle = Math.atan2(dy, dx);
  let steps = Math.ceil(dist / (r*0.7));
  for (let i=0; i<steps; ++i) {
    let t = i/steps;
    let cx = from.x + dx*t + (Math.random()-0.5)*r*0.12;
    let cy = from.y + dy*t + (Math.random()-0.5)*r*0.07;
    const width = Math.round(r*1.35), height = Math.round(r*0.46);
    const left = Math.round(cx-width/2), top = Math.round(cy-height/2);
    if(left<0||top<0||left+width>canvas.width||top+height>canvas.height) continue;
    const imgData = ctx.getImageData(left, top, width, height);
    for (let yy=0;yy<height;yy++) for (let xx=0;xx<width;xx++) {
      let ex = (xx-width/2)/width, ey = (yy-height/2)/height;
      if (Math.abs(ex)*2 + Math.abs(ey)*1.4 > 1) continue;
      const idx = (yy*width+xx)*4;
      const old = [imgData.data[idx], imgData.data[idx+1], imgData.data[idx+2]];
      let jitter = (Math.random()-0.5)*0.1;
      let mixRatio = 0.55*oiliness + 0.25 + jitter;
      mixRatio = Math.max(0, Math.min(1, mixRatio));
      const mixed = rybMix(old, color, mixRatio);
      imgData.data[idx]=mixed[0];
      imgData.data[idx+1]=mixed[1];
      imgData.data[idx+2]=mixed[2];
      imgData.data[idx+3]=Math.min(255, imgData.data[idx+3] + 200);
    }
    ctx.putImageData(imgData, left, top);
    if (lighting && Math.random()<0.2) {
      ctx.save();
      ctx.globalAlpha = 0.2;
      ctx.translate(cx, cy);
      ctx.rotate(angle);
      const grad = ctx.createLinearGradient(-width/2, 0, width/2, 0);
      grad.addColorStop(0, "rgba(255,255,255,0.3)");
      grad.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = grad;
      ctx.fillRect(-width/2, -height/2, width, height);
      ctx.restore();
    }
  }
}

function drawStroke(from, to) {
  const color = hexToRgb(brushColor);
  let dx = to.x - from.x, dy = to.y - from.y;
  let angle = Math.atan2(dy, dx);
  if (tool === 'brush') {
    const dist = Math.sqrt(dx*dx + dy*dy);
    const steps = Math.ceil(dist / (brushSize * 0.22));
    for (let i = 0; i < steps; i++) {
      const t = i / steps;
      const x = from.x + dx * t + (Math.random()-0.5)*brushSize*0.05;
      const y = from.y + dy * t + (Math.random()-0.5)*brushSize*0.05;
      const r = brushSize/2 * (0.92 + 0.14*Math.random());
      dabImpasto(x, y, r, color, oiliness, lighting, angle);
    }
  } else if (tool === 'knife') {
    knifeStroke(from, to, brushSize, color, oiliness, lighting);
  }
}
</script>
</body>
</html>
