function drawTo(x,y){
    // --- START: Changes ---
    // Convert normalized coordinates (0-1) to pixel coordinates for accurate distance calculation
    const currentPixel = { x: x * paint.width, y: y * paint.height };
    const lastPixel = last ? { x: last[0] * paint.width, y: last[1] * paint.height } : null;
    // --- END: Changes ---

    const s = parseFloat(sizeEl.value)*pixelRatio;
    const flow = parseFloat(flowEl.value)/100; // coverage
    const wet = parseFloat(wetEl.value)/100;   // mixing
    const imp = parseFloat(impEl.value)/100;   // height
    const [br, bg, bb] = hexToRgb(colorEl.value);

    const tool = toolEl.value;
    // --- START: Changes ---
    // Calculate distance in pixels, not normalized units. This is the key fix.
    const dist = lastPixel ? Math.hypot(currentPixel.x - lastPixel.x, currentPixel.y - lastPixel.y) : 0;
    // Now that 'dist' is in pixels, this calculation correctly determines how many dabs are needed to fill the gap.
    const steps = 1 + ((dist/(s*0.35))|0);
    // --- END: Changes ---

    for(let i=1;i<=steps;i++){
      // The interpolation itself is still done with normalized coordinates, which is correct.
      const t = i/steps;
      const tx = last? lerp(last[0], x, t) : x;
      const ty = last? lerp(last[1], y, t) : y;
      const px = (tx*paint.width)|0, py = (ty*paint.height)|0; // centers in px
      const r = (s/2)|0; const dSize = (r*2)|0;

      // Create dab
      const dab = bristleMask; // already sized ~s

      if(tool==='brush'){
        ctxP.save();
        // Mix existing pixels underneath by drawing lighter on alpha, then tint
        // Draw the colored dab to a temp canvas to control alpha
        const temp = document.createElement('canvas'); temp.width=dab.width; temp.height=dab.height; const tc=temp.getContext('2d');
        tc.drawImage(dab,0,0);
        // tint
        tc.globalCompositeOperation='source-in'; tc.fillStyle=`rgba(${br},${bg},${bb},${flow})`; tc.fillRect(0,0,temp.width,temp.height);

        // color pickup: read small sample at center and blend into brush color (wetness)
        const sampleSize = Math.max(2, (s*0.25)|0);
        try{
          const sample = ctxP.getImageData(px-sampleSize/2, py-sampleSize/2, sampleSize, sampleSize).data;
          let sr=0, sg=0, sb=0, count=0; for(let k=0;k<sample.length;k+=4){ const a=sample[k+3]/255; sr += sample[k]*a; sg += sample[k+1]*a; sb += sample[k+2]*a; count+=a; }
          if(count>0){ sr/=count; sg/=count; sb/=count; pickupColor=[sr,sg,sb]; }
        }catch(e){}
        const mr = lerp(br, pickupColor[0], wet), mg = lerp(bg, pickupColor[1], wet), mb = lerp(bb, pickupColor[2], wet);
        // retint with mixed color
        tc.globalCompositeOperation='source-in'; tc.fillStyle=`rgba(${mr|0},${mg|0},${mb|0},1)`; tc.fillRect(0,0,temp.width,temp.height);

        // lay paint
        ctxP.globalAlpha = 1; ctxP.globalCompositeOperation='source-over';
        ctxP.drawImage(temp, px-r, py-r, dSize, dSize);
        ctxP.restore();

        // raise height map (impasto). We fake via soft highlight + shadow into height canvas
        ctxH.save();
        ctxH.globalCompositeOperation='source-over';
        // positive bump
        ctxH.filter = 'blur(0.5px)';
        ctxH.fillStyle = `rgba(255,255,255,${imp*0.5})`;
        ctxH.beginPath(); ctxH.arc(px,py,r*0.85,0,Math.PI*2); ctxH.fill();
        // slight trough around
        ctxH.globalCompositeOperation='destination-out';
        ctxH.beginPath(); ctxH.arc(px,py,r,0,Math.PI*2); ctxH.lineWidth = r*0.25; ctxH.stroke();
        ctxH.restore();

      } else if(tool==='knife'){
        // Drag paint in the movement direction (like a smear) and flatten height
        if(last){
          const dx = x-last[0], dy = y-last[1];
          const len = Math.hypot(dx,dy)||1; const nx=dx/len, ny=dy/len;
          const w = s*1.2, l = s*1.8;
          const sx = (last[0]*paint.width - w/2)|0; const sy = (last[1]*paint.height - l/2)|0;
          const sw = (w)|0; const sh=(l)|0;
          try{
            const slice = ctxP.getImageData(sx,sy,sw,sh);
            // simple directional smear by shifting rows/cols
            for(let row=0; row<sh; row++){
              const offset = ((row*nx+row*ny)|0); // crude but fast
            }
            // Draw the slice slightly offset in motion direction to create smear
            ctxP.putImageData(slice, sx + (dx*pixelRatio)|0, sy + (dy*pixelRatio)|0);
          }catch(e){}
          // flatten
          ctxH.save(); ctxH.globalAlpha = .6; ctxH.globalCompositeOperation='destination-out';
          ctxH.beginPath(); ctxH.ellipse(px,py, s*0.6, s*0.25, Math.atan2(dy,dx), 0, Math.PI*2); ctxH.fill(); ctxH.restore();
        }
      } else if(tool==='smudge'){
        // pick up and re-apply color (no new pigment)
        try{
          const area = ctxP.getImageData(px-r,py-r,dSize,dSize);
          ctxP.putImageData(area, px-r + ((x-(last?.[0]??x))*pixelRatio)|0, py-r + ((y-(last?.[1]??y))*pixelRatio)|0);
        }catch(e){}
        // slight height blur
        ctxH.save(); ctxH.filter='blur(1.2px)'; ctxH.globalAlpha=.6; ctxH.drawImage(height, px-r,py-r,dSize,dSize, px-r,py-r,dSize,dSize); ctxH.restore();
      } else if(tool==='eraser'){
        ctxP.save(); ctxP.globalCompositeOperation='destination-out'; ctxP.drawImage(dab, px-r, py-r, dSize, dSize); ctxP.restore();
        ctxH.save(); ctxH.globalCompositeOperation='destination-out'; ctxH.drawImage(dab, px-r, py-r, dSize, dSize); ctxH.restore();
      }
    }
    last=[x,y];
    render();
  }